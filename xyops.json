{
	"type": "xypdf",
	"description": "xyOps Portable Data Object",
	"version": "1.0",
	"items": [
		{
			"type": "plugin",
			"data": {
				"title": "MSSQL Information",
				"enabled": true,
				"type": "event",
				"command": "pwsh",
				"script": "# (c)2026 Tim Alderweireldt - xyOps MSSQL Information Plugin - PowerShell Version\n# Collects comprehensive information from Microsoft SQL Server instances using dbatools\n\nfunction Write-Output-JSON {\n    param($Object)\n    $json = $Object | ConvertTo-Json -Compress -Depth 100\n    Write-Output $json\n    [Console]::Out.Flush()\n}\n\nfunction Send-Progress {\n    param([double]$Value)\n    Write-Output-JSON @{ xy = 1; progress = $Value }\n}\n\nfunction Send-Table {\n    param($Title, $Data, $Caption = \"\")\n    \n    if ($null -eq $Data -or $Data.Count -eq 0) {\n        return\n    }\n    \n    # Convert data to array of PSCustomObjects if it's hashtables\n    $tableData = $Data | ForEach-Object { \n        if ($_ -is [hashtable]) {\n            [PSCustomObject]$_\n        } else {\n            $_\n        }\n    }\n    \n    $headers = $tableData[0].PSObject.Properties.Name\n    $rows = @()\n    \n    foreach ($record in $tableData) {\n        $row = @()\n        foreach ($header in $headers) {\n            $value = $record.$header\n            if ($null -eq $value) {\n                $row += \"\"\n            }\n            elseif ($value -is [array] -or $value -is [hashtable]) {\n                $row += ($value | ConvertTo-Json -Compress)\n            }\n            else {\n                $row += $value.ToString()\n            }\n        }\n        $rows += ,@($row)\n    }\n    \n    Write-Output-JSON @{\n        xy = 1\n        table = @{\n            title = $Title\n            header = $headers\n            rows = $rows\n            caption = if ($Caption) { $Caption } else { \"$($tableData.Count) row(s)\" }\n        }\n    }\n}\n\nfunction Send-Success {\n    param([string]$Description = \"Information collected successfully\")\n    Write-Output-JSON @{ xy = 1; code = 0; description = $Description }\n}\n\nfunction Send-Error {\n    param([int]$Code, [string]$Description)\n    Write-Output-JSON @{ xy = 1; code = $Code; description = $Description }\n}\n\n# Read input from STDIN\n$inputJson = [Console]::In.ReadToEnd()\n\ntry {\n    $jobData = $inputJson | ConvertFrom-Json -AsHashtable\n}\ncatch {\n    Send-Error -Code 1 -Description \"Failed to parse input JSON: $($_.Exception.Message)\"\n    exit 1\n}\n\n# Extract parameters\n$params = $jobData.params\n\n# Helper function to get parameter value case-insensitively\nfunction Get-ParamValue {\n    param($ParamsObject, [string]$ParamName)\n    if ($ParamsObject -is [hashtable]) {\n        foreach ($key in $ParamsObject.Keys) {\n            if ($key -ieq $ParamName) {\n                return $ParamsObject[$key]\n            }\n        }\n        return $null\n    } else {\n        $prop = $ParamsObject.PSObject.Properties | Where-Object { $_.Name -ieq $ParamName } | Select-Object -First 1\n        if ($prop) { return $prop.Value }\n        return $null\n    }\n}\n\n# Check if debug mode is enabled\n$debugRaw = Get-ParamValue -ParamsObject $params -ParamName 'debug'\n$debug = if ($debugRaw -eq $true -or $debugRaw -eq \"true\" -or $debugRaw -eq \"True\") { $true } else { $false }\n\n# If debug is enabled, output the incoming JSON\nif ($debug) {\n    Write-Host \"=== DEBUG: Incoming JSON ===\"\n    $debugData = @{}\n    if ($jobData -is [hashtable]) {\n        foreach ($key in $jobData.Keys) {\n            if ($key -ne 'script') {\n                $debugData[$key] = $jobData[$key]\n            }\n        }\n    } else {\n        foreach ($prop in $jobData.PSObject.Properties) {\n            if ($prop.Name -ne 'script') {\n                $debugData[$prop.Name] = $prop.Value\n            }\n        }\n    }\n    $formattedJson = $debugData | ConvertTo-Json -Depth 10\n    Write-Host $formattedJson\n    Write-Host \"=== END DEBUG ===\"\n}\n\n$server = Get-ParamValue -ParamsObject $params -ParamName 'server'\n$username = $env:MSSQLINFO_USERNAME\n$password = $env:MSSQLINFO_PASSWORD\n$excludeDatabasesRaw = Get-ParamValue -ParamsObject $params -ParamName 'excludedatabases'\n$excludeDatabases = if ([string]::IsNullOrWhiteSpace($excludeDatabasesRaw)) { @() } else { $excludeDatabasesRaw -split ',' | ForEach-Object { $_.Trim() } }\n$exportFormatRaw = Get-ParamValue -ParamsObject $params -ParamName 'exportformat'\n$exportFormat = if ([string]::IsNullOrWhiteSpace($exportFormatRaw)) { \"JSON\" } else { $exportFormatRaw.ToUpper() }\n$exportToFileRaw = Get-ParamValue -ParamsObject $params -ParamName 'exporttofile'\n$exportToFile = if ($exportToFileRaw -eq $true -or $exportToFileRaw -eq \"true\" -or $exportToFileRaw -eq \"True\") { $true } else { $false }\n\n# Validate required parameters\n$missing = @()\n\n# Check server parameter\nif ([string]::IsNullOrWhiteSpace($server)) {\n    $missing += 'server'\n}\n\n# Check username from environment variable\nif ([string]::IsNullOrWhiteSpace($username)) {\n    $missing += 'MSSQLINFO_USERNAME (environment variable)'\n}\n\n# Check password from environment variable\nif ([string]::IsNullOrWhiteSpace($password)) {\n    $missing += 'MSSQLINFO_PASSWORD (environment variable)'\n}\n\nif ($missing.Count -gt 0) {\n    Send-Error -Code 2 -Description \"Missing required parameters: $($missing -join ', '). Credentials must be provided via secret vault environment variables.\"\n    exit 1\n}\n\ntry {\n    # Check if dbatools module is installed\n    Send-Progress -Value 0.1\n    \n    if (-not (Get-Module -ListAvailable -Name dbatools)) {\n        try {\n            Write-Host \"dbatools module not found, attempting to install...\"\n            Install-Module -Name dbatools -Force -AllowClobber -Scope CurrentUser -ErrorAction Stop\n            Write-Host \"dbatools module installed successfully\"\n        }\n        catch {\n            Send-Error -Code 3 -Description \"Failed to install required dbatools module. Please install it manually by running: Install-Module -Name dbatools -Force (Install error: $($_.Exception.Message))\"\n            exit 1\n        }\n    }\n    \n    # Import dbatools module\n    Send-Progress -Value 0.2\n    Import-Module dbatools -ErrorAction Stop\n    \n    # Build connection parameters\n    Send-Progress -Value 0.3\n    \n    # Extract and convert encryption parameters\n    $useencryptionRaw = Get-ParamValue -ParamsObject $params -ParamName 'useencryption'\n    $trustcertRaw = Get-ParamValue -ParamsObject $params -ParamName 'trustcert'\n    \n    $securePassword = ConvertTo-SecureString -String $password -AsPlainText -Force\n    $credential = New-Object System.Management.Automation.PSCredential($username, $securePassword)\n    \n    # Build Connect-DbaInstance parameters with encryption settings\n    $connectParams = @{\n        SqlInstance = $server\n        SqlCredential = $credential\n    }\n    \n    # Add encryption parameter if enabled\n    if ($useencryptionRaw -eq $true -or $useencryptionRaw -eq \"true\" -or $useencryptionRaw -eq \"True\") {\n        $connectParams['EncryptConnection'] = $true\n        Write-Host \"Encryption enabled\"\n    }\n    \n    # Add TrustServerCertificate parameter if enabled\n    if ($trustcertRaw -eq $true -or $trustcertRaw -eq \"true\" -or $trustcertRaw -eq \"True\") {\n        $connectParams['TrustServerCertificate'] = $true\n        Write-Host \"TrustServerCertificate enabled\"\n    }\n    \n    # Create connection using Connect-DbaInstance\n    Write-Host \"Connecting to $server with encryption=$useencryptionRaw, trustcert=$trustcertRaw\"\n    $serverConnection = Connect-DbaInstance @connectParams\n    \n    Send-Progress -Value 0.4\n    \n    # Collect server information\n    Write-Host \"Collecting server information...\"\n    \n    # Determine patch level (show RTM if not patched)\n    $patchLevel = if ([string]::IsNullOrWhiteSpace($serverConnection.ProductUpdateLevel)) { \"RTM (Not Patched)\" } else { $serverConnection.ProductUpdateLevel }\n    \n    # Extract current CU number if available\n    $currentCuNumber = $null\n    if ($patchLevel -match 'CU\\s?(\\d+)') {\n        $currentCuNumber = [int]$matches[1]\n        Write-Host \"Current CU installed: CU$currentCuNumber\"\n    } elseif ($patchLevel -ne \"RTM (Not Patched)\") {\n        Write-Host \"Current patch level: $patchLevel\"\n    } else {\n        Write-Host \"No CU installed (RTM version)\"\n    }\n    \n    # Get major version from VersionString (e.g., \"16.0.1000.6\" -> \"2022\")\n    $versionMajor = $serverConnection.VersionMajor\n    $sqlVersionName = switch ($versionMajor) {\n        16 { \"SQL Server 2022\" }\n        15 { \"SQL Server 2019\" }\n        14 { \"SQL Server 2017\" }\n        13 { \"SQL Server 2016\" }\n        12 { \"SQL Server 2014\" }\n        11 { \"SQL Server 2012\" }\n        10 { \"SQL Server 2008/2008 R2\" }\n        default { \"SQL Server (Unknown Version)\" }\n    }\n    \n    # Get latest CU download link based on version\n    Write-Host \"Getting latest CU info for $sqlVersionName...\"\n    $latestCU = \"N/A\"\n    $downloadLink = \"\"\n    $cuNumber = \"\"\n    \n    # Try to fetch latest CU number from Microsoft's update history pages\n    try {\n        $buildReferenceUrl = switch ($versionMajor) {\n            16 { \"https://learn.microsoft.com/en-us/troubleshoot/sql/releases/sqlserver-2022/build-versions\" }\n            15 { \"https://learn.microsoft.com/en-us/troubleshoot/sql/releases/sqlserver-2019/build-versions\" }\n            14 { \"https://learn.microsoft.com/en-us/troubleshoot/sql/releases/sqlserver-2017/build-versions\" }\n            13 { \"https://learn.microsoft.com/en-us/troubleshoot/sql/releases/sqlserver-2016/build-versions\" }\n            default { $null }\n        }\n        \n        if ($buildReferenceUrl) {\n            Write-Host \"Fetching latest CU from: $buildReferenceUrl\"\n            $response = Invoke-WebRequest -Uri $buildReferenceUrl -TimeoutSec 10 -UseBasicParsing -ErrorAction Stop\n            \n            # Look for CU pattern in the content (e.g., \"CU15\", \"CU 15\", \"Cumulative Update 15\")\n            if ($response.Content -match 'CU\\s?(\\d+)|Cumulative Update\\s+(\\d+)') {\n                # Find all CU numbers and get the highest one\n                $cuMatches = [regex]::Matches($response.Content, 'CU\\s?(\\d+)|Cumulative Update\\s+(\\d+)')\n                $cuNumbers = @()\n                foreach ($match in $cuMatches) {\n                    if ($match.Groups[1].Value) {\n                        $cuNumbers += [int]$match.Groups[1].Value\n                    } elseif ($match.Groups[2].Value) {\n                        $cuNumbers += [int]$match.Groups[2].Value\n                    }\n                }\n                if ($cuNumbers.Count -gt 0) {\n                    $latestCuNum = ($cuNumbers | Measure-Object -Maximum).Maximum\n                    $cuNumber = \"CU$latestCuNum\"\n                    Write-Host \"Latest CU detected: $cuNumber\"\n                    \n                    # Compare with current CU if available\n                    if ($null -ne $currentCuNumber) {\n                        if ($currentCuNumber -eq $latestCuNum) {\n                            Write-Host \"Server is up-to-date (CU$currentCuNumber = $cuNumber)\"\n                        } elseif ($currentCuNumber -lt $latestCuNum) {\n                            $cusBehind = $latestCuNum - $currentCuNumber\n                            Write-Host \"Server is $cusBehind CU(s) behind (Current: CU$currentCuNumber, Latest: $cuNumber)\"\n                        } else {\n                            Write-Host \"Server has newer version than detected (Current: CU$currentCuNumber, Latest: $cuNumber)\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n    catch {\n        Write-Host \"Could not fetch latest CU number: $($_.Exception.Message)\"\n    }\n    \n    # Determine update status\n    $updateStatus = \"Unknown\"\n    if ($cuNumber -match 'CU(\\d+)') {\n        $latestCuNum = [int]$matches[1]\n        if ($null -ne $currentCuNumber) {\n            if ($currentCuNumber -eq $latestCuNum) {\n                $updateStatus = \"✅ Up-to-date\"\n            } elseif ($currentCuNumber -lt $latestCuNum) {\n                $cusBehind = $latestCuNum - $currentCuNumber\n                $updateStatus = \"⚠️ $cusBehind CU(s) behind\"\n            } else {\n                $updateStatus = \"✅ Newer than latest detected\"\n            }\n        } elseif ($patchLevel -eq \"RTM (Not Patched)\") {\n            $updateStatus = \"⚠️ Not patched (RTM)\"\n        }\n    }\n    \n    # Build the download link text with CU number if found\n    $latestCU = switch ($versionMajor) {\n        16 { \n            $downloadLink = \"https://www.microsoft.com/en-us/download/details.aspx?id=105013\"\n            if ($cuNumber) {\n                \"[SQL Server 2022 $cuNumber (Download)]($downloadLink)\"\n            } else {\n                \"[Latest CU for SQL Server 2022 (Download)]($downloadLink)\"\n            }\n        }\n        15 { \n            $downloadLink = \"https://www.microsoft.com/en-us/download/details.aspx?id=100809\"\n            if ($cuNumber) {\n                \"[SQL Server 2019 $cuNumber (Download)]($downloadLink)\"\n            } else {\n                \"[Latest CU for SQL Server 2019 (Download)]($downloadLink)\"\n            }\n        }\n        14 { \n            $downloadLink = \"https://www.microsoft.com/en-us/download/details.aspx?id=56128\"\n            if ($cuNumber) {\n                \"[SQL Server 2017 $cuNumber (Download)]($downloadLink)\"\n            } else {\n                \"[Latest CU for SQL Server 2017 (Download)]($downloadLink)\"\n            }\n        }\n        13 { \n            $downloadLink = \"https://www.microsoft.com/en-us/download/details.aspx?id=53338\"\n            if ($cuNumber) {\n                \"[SQL Server 2016 $cuNumber (Download)]($downloadLink)\"\n            } else {\n                \"[Latest Service Pack for SQL Server 2016 (Download)]($downloadLink)\"\n            }\n        }\n        12 { \n            \"End of Support - No longer receiving updates\"\n        }\n        default { \n            \"Version out of mainstream support\"\n        }\n    }\n    \n    $serverInfo = @{\n        ServerName = $serverConnection.Name\n        SQLVersion = $sqlVersionName\n        Version = $serverConnection.VersionString\n        BuildNumber = $serverConnection.BuildNumber\n        Edition = $serverConnection.Edition\n        ProductLevel = $serverConnection.ProductLevel\n        ProductUpdateLevel = $patchLevel\n        UpdateStatus = $updateStatus\n        LatestCU = $latestCU\n        IsClustered = if ($serverConnection.IsClustered) { \"Yes\" } else { \"No\" }\n        IsHadrEnabled = if ($serverConnection.IsHadrEnabled) { \"Yes\" } else { \"No\" }\n    }\n    \n    Send-Progress -Value 0.5\n    \n    # Initialize data collections\n    $allData = @{\n        server = $serverInfo\n        availabilityGroups = @()\n        databases = @()\n        databaseUsers = @()\n    }\n    \n    # Collect Availability Groups information if enabled\n    if ($serverConnection.IsHadrEnabled) {\n        Write-Host \"Collecting Availability Groups information...\"\n        try {\n            $ags = Get-DbaAvailabilityGroup -SqlInstance $serverConnection\n            \n            foreach ($ag in $ags) {\n                $agInfo = @{\n                    Name = $ag.Name\n                    PrimaryReplica = $ag.PrimaryReplica\n                    LocalReplicaRole = $ag.LocalReplicaRole.ToString()\n                    AutomatedBackupPreference = $ag.AutomatedBackupPreference.ToString()\n                }\n                \n                # Get listener information\n                $listener = $ag.AvailabilityGroupListeners | Select-Object -First 1\n                if ($listener) {\n                    $agInfo['ListenerDNS'] = $listener.Name\n                    $agInfo['ListenerPort'] = $listener.PortNumber.ToString()\n                    $agInfo['ListenerIP'] = ($listener.AvailabilityGroupListenerIPAddresses | Select-Object -ExpandProperty IPAddress) -join ', '\n                } else {\n                    $agInfo['ListenerDNS'] = \"N/A\"\n                    $agInfo['ListenerPort'] = \"N/A\"\n                    $agInfo['ListenerIP'] = \"N/A\"\n                }\n                \n                # Get replicas\n                $replicas = Get-DbaAgReplica -SqlInstance $serverConnection -AvailabilityGroup $ag.Name\n                $agInfo['Replicas'] = ($replicas.Name -join ', ')\n                \n                $allData.availabilityGroups += $agInfo\n            }\n        }\n        catch {\n            Write-Host \"Warning: Could not collect AG information: $($_.Exception.Message)\"\n        }\n    }\n    \n    Send-Progress -Value 0.6\n    \n    # Collect database information\n    Write-Host \"Collecting database information...\"\n    $systemDatabases = @('master', 'model', 'msdb', 'tempdb')\n    $databases = Get-DbaDatabase -SqlInstance $serverConnection | Where-Object { \n        $systemDatabases -notcontains $_.Name -and $excludeDatabases -notcontains $_.Name \n    }\n    \n    Send-Progress -Value 0.7\n    \n    foreach ($db in $databases) {\n        Write-Host \"Processing database: $($db.Name)\"\n        \n        # Determine which server to query for this database\n        $queryConnection = $serverConnection\n        $connectionNote = \"\"\n        \n        # Check if database is in AG and not accessible on this replica\n        if ($db.AvailabilityGroupName) {\n            Write-Host \"Database $($db.Name) is in AG: $($db.AvailabilityGroupName)\"\n            \n            # Try to find the primary replica for this AG\n            try {\n                $ag = Get-DbaAvailabilityGroup -SqlInstance $serverConnection -AvailabilityGroup $db.AvailabilityGroupName -ErrorAction Stop\n                $primaryReplica = $ag.PrimaryReplica\n                \n                # If we're not on the primary, try to connect to it\n                if ($primaryReplica -and $primaryReplica -ne $serverConnection.Name) {\n                    Write-Host \"Database is on AG, primary replica is $primaryReplica (current: $($serverConnection.Name))\"\n                    \n                    try {\n                        # Try to connect to primary replica with same credentials\n                        $primaryConnectParams = @{\n                            SqlInstance = $primaryReplica\n                            SqlCredential = $credential\n                        }\n                        \n                        if ($useencryptionRaw -eq $true -or $useencryptionRaw -eq \"true\" -or $useencryptionRaw -eq \"True\") {\n                            $primaryConnectParams['EncryptConnection'] = $true\n                        }\n                        if ($trustcertRaw -eq $true -or $trustcertRaw -eq \"true\" -or $trustcertRaw -eq \"True\") {\n                            $primaryConnectParams['TrustServerCertificate'] = $true\n                        }\n                        \n                        $queryConnection = Connect-DbaInstance @primaryConnectParams -ErrorAction Stop\n                        $connectionNote = \" (via primary: $primaryReplica)\"\n                        Write-Host \"Successfully connected to primary replica: $primaryReplica\"\n                    }\n                    catch {\n                        Write-Host \"Warning: Could not connect to primary replica $primaryReplica : $($_.Exception.Message)\"\n                        Write-Host \"Will attempt to query on current server anyway\"\n                    }\n                }\n            }\n            catch {\n                Write-Host \"Warning: Could not determine AG primary for $($db.Name): $($_.Exception.Message)\"\n            }\n        }\n        \n        # Get last backup information\n        $lastFullBackup = Get-DbaDbBackupHistory -SqlInstance $queryConnection -Database $db.Name -LastFull -WarningAction SilentlyContinue | Select-Object -First 1\n        \n        # Get database size - separate data and log files using dbatools\n        $dataSize = 0\n        $logSize = 0\n        \n        try {\n            # Get file information using dbatools to avoid SMO enumeration issues\n            $dbFiles = Get-DbaDbFile -SqlInstance $queryConnection -Database $db.Name -ErrorAction Stop\n            \n            foreach ($file in $dbFiles) {\n                if ($file.TypeDescription -eq 'LOG') {\n                    $logSize += $file.Size.Megabyte\n                } else {\n                    $dataSize += $file.Size.Megabyte\n                }\n            }\n            \n            $dataSizeGB = [math]::Round($dataSize / 1024, 2)\n            $logSizeGB = [math]::Round($logSize / 1024, 2)\n            $totalSizeGB = [math]::Round(($dataSize + $logSize) / 1024, 2)\n        }\n        catch {\n            Write-Host \"Warning: Could not get file sizes for $($db.Name), using database total size: $($_.Exception.Message)\"\n            # Fallback to total database size if file enumeration fails\n            $totalSizeGB = [math]::Round($db.Size / 1KB, 2)\n            $dataSizeGB = $totalSizeGB\n            $logSizeGB = 0\n        }\n        \n        # Check if database is in AG\n        $inAG = if ($db.AvailabilityGroupName) { \"Yes ($($db.AvailabilityGroupName))\" } else { \"No\" }\n        \n        # Get active connections\n        $connections = (Get-DbaProcess -SqlInstance $queryConnection -Database $db.Name).Count\n        \n        $dbInfo = @{\n            DatabaseName = $db.Name + $connectionNote\n            DataSizeGB = $dataSizeGB\n            LogSizeGB = $logSizeGB\n            TotalSizeGB = $totalSizeGB\n            Status = $db.Status.ToString()\n            RecoveryModel = $db.RecoveryModel.ToString()\n            Owner = $db.Owner\n            ActiveConnections = $connections\n            InAvailabilityGroup = $inAG\n            LastFullBackup = if ($lastFullBackup) { $lastFullBackup.End.ToString(\"yyyy-MM-dd HH:mm:ss\") } else { \"Never\" }\n            CompatibilityLevel = $db.CompatibilityLevel.ToString()\n        }\n        \n        $allData.databases += $dbInfo\n        \n        # Collect database users with permissions\n        try {\n            $users = Get-DbaDbUser -SqlInstance $queryConnection -Database $db.Name | Where-Object { \n                -not $_.IsSystemObject \n            }\n            \n            foreach ($user in $users) {\n                # Get user roles/permissions using dbatools\n                $roles = @()\n                try {\n                    # Use Get-DbaDbRoleMember to get role memberships\n                    $roleMemberships = Get-DbaDbRoleMember -SqlInstance $queryConnection -Database $db.Name -IncludeSystemUser -ErrorAction Stop | Where-Object { $_.UserName -eq $user.Name }\n                    \n                    if ($roleMemberships) {\n                        $roles = @($roleMemberships | Select-Object -ExpandProperty Role -Unique)\n                    }\n                } catch {\n                    Write-Host \"Could not get roles for user $($user.Name) in $($db.Name): $($_.Exception.Message)\"\n                }\n                \n                $rolesList = if ($roles.Count -gt 0) { $roles -join ', ' } else { \"None\" }\n                \n                $userInfo = @{\n                    DatabaseName = $db.Name\n                    UserName = $user.Name\n                    LoginType = $user.LoginType.ToString()\n                    Roles = $rolesList\n                    CreateDate = $user.CreateDate.ToString(\"yyyy-MM-dd HH:mm:ss\")\n                    HasDBAccess = if ($user.HasDBAccess) { \"Yes\" } else { \"No\" }\n                }\n                \n                $allData.databaseUsers += $userInfo\n            }\n        }\n        catch {\n            Write-Host \"Warning: Could not collect users for database $($db.Name): $($_.Exception.Message)\"\n        }\n    }\n    \n    Send-Progress -Value 0.9\n    \n    # Build Markdown output with sections\n    Write-Host \"Building Markdown output...\"\n    $markdownContent = \"\"\n    \n    # Server Information Section\n    $markdownContent += \"## Server Information`n`n\"\n    $markdownContent += \"| Property | Value |`n\"\n    $markdownContent += \"|----------|-------|`n\"\n    $markdownContent += \"| **Server Name** | $($serverInfo.ServerName) |`n\"\n    $markdownContent += \"| **SQL Version** | $($serverInfo.SQLVersion) |`n\"\n    $markdownContent += \"| **Version String** | $($serverInfo.Version) |`n\"\n    $markdownContent += \"| **Build Number** | $($serverInfo.BuildNumber) |`n\"\n    $markdownContent += \"| **Edition** | $($serverInfo.Edition) |`n\"\n    $markdownContent += \"| **Product Level** | $($serverInfo.ProductLevel) |`n\"\n    $markdownContent += \"| **Current Patch** | $($serverInfo.ProductUpdateLevel) |`n\"\n    $markdownContent += \"| **Update Status** | $($serverInfo.UpdateStatus) |`n\"\n    $markdownContent += \"| **Latest CU Download** | $($serverInfo.LatestCU) |`n\"\n    $markdownContent += \"| **Is Clustered** | $($serverInfo.IsClustered) |`n\"\n    $markdownContent += \"| **HADR Enabled** | $($serverInfo.IsHadrEnabled) |`n\"\n    $markdownContent += \"`n\"\n    \n    # Availability Groups Section\n    if ($allData.availabilityGroups.Count -gt 0) {\n        $markdownContent += \"## Availability Groups ($($allData.availabilityGroups.Count))`n`n\"\n        $markdownContent += \"| AG Name | Primary Replica | Role | Listener | Replicas |`n\"\n        $markdownContent += \"|---------|----------------|------|----------|----------|`n\"\n        \n        foreach ($ag in $allData.availabilityGroups) {\n            $listener = \"$($ag.ListenerDNS):$($ag.ListenerPort) (IP: $($ag.ListenerIP))\"\n            $markdownContent += \"| **$($ag.Name)** | $($ag.PrimaryReplica) | $($ag.LocalReplicaRole) | $listener | $($ag.Replicas) |`n\"\n        }\n        \n        $markdownContent += \"`n\"\n    }\n    \n    # Databases Section\n    if ($allData.databases.Count -gt 0) {\n        $markdownContent += \"## Databases ($($allData.databases.Count))`n`n\"\n        $markdownContent += \"| Database | Data (GB) | Log (GB) | Total (GB) | Status | Recovery Model | Owner | Connections | Last Backup | In AG |`n\"\n        $markdownContent += \"|----------|-----------|----------|------------|--------|----------------|-------|-------------|-------------|-------|`n\"\n        \n        foreach ($db in $allData.databases) {\n            $markdownContent += \"| **$($db.DatabaseName)** | $($db.DataSizeGB) | $($db.LogSizeGB) | $($db.TotalSizeGB) | $($db.Status) | $($db.RecoveryModel) | $($db.Owner) | $($db.ActiveConnections) | $($db.LastFullBackup) | $($db.InAvailabilityGroup) |`n\"\n        }\n        \n        $markdownContent += \"`n\"\n    }\n    \n    # Database Users Section\n    if ($allData.databaseUsers.Count -gt 0) {\n        $markdownContent += \"## Database Users ($($allData.databaseUsers.Count))`n`n\"\n        $markdownContent += \"| Database | User Name | Login Type | Roles/Permissions | Has DB Access | Created |`n\"\n        $markdownContent += \"|----------|-----------|------------|-------------------|---------------|---------|`n\"\n        \n        foreach ($user in $allData.databaseUsers) {\n            $markdownContent += \"| $($user.DatabaseName) | **$($user.UserName)** | $($user.LoginType) | $($user.Roles) | $($user.HasDBAccess) | $($user.CreateDate) |`n\"\n        }\n        \n        $markdownContent += \"`n\"\n    }\n    \n    # Always output the Markdown for display\n    $caption = \"Server: $($serverInfo.ServerName) | $($allData.databases.Count) Database(s) | $($allData.databaseUsers.Count) User(s) | $($allData.availabilityGroups.Count) Availability Group(s)\"\n    Write-Output-JSON @{\n        xy = 1\n        markdown = @{\n            title = \"SQL Server Information Report\"\n            content = $markdownContent\n            caption = $caption\n        }\n    }\n    \n    # Output data in requested format\n    Write-Host \"Outputting data in $exportFormat format...\"\n    \n    switch ($exportFormat) {\n        \"JSON\" {\n            if ($exportToFile) {\n                # Generate filename with timestamp\n                $timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n                $filename = \"sqlserver_info_$($serverInfo.ServerName)_$timestamp.json\"\n                \n                # Write JSON to file\n                $allData | ConvertTo-Json -Depth 100 | Out-File -FilePath $filename -Encoding UTF8\n                Write-Host \"JSON file created: $filename\"\n                \n                # Output JSON data AND file reference\n                $jsonData = @{\n                    xy = 1\n                    data = $allData\n                    files = @(\n                        @{\n                            path = $filename\n                            name = $filename\n                        }\n                    )\n                }\n                Write-Output-JSON $jsonData\n            } else {\n                # Output JSON data only (no file)\n                $jsonData = @{\n                    xy = 1\n                    data = $allData\n                }\n                Write-Output-JSON $jsonData\n            }\n        }\n        \"CSV\" {\n            # Build separate CSV files for each section\n            Write-Host \"Building CSV output...\"\n            $timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n            $csvFiles = @()\n            \n            # Server Information CSV\n            $serverCsv = \"Property,Value`n\"\n            $serverCsv += \"Server Name,$($serverInfo.ServerName)`n\"\n            $serverCsv += \"SQL Version,$($serverInfo.SQLVersion)`n\"\n            $serverCsv += \"Version String,$($serverInfo.Version)`n\"\n            $serverCsv += \"Build Number,$($serverInfo.BuildNumber)`n\"\n            $serverCsv += \"Edition,`\"$($serverInfo.Edition)`\"`n\"\n            $serverCsv += \"Product Level,$($serverInfo.ProductLevel)`n\"\n            $serverCsv += \"Current Patch,$($serverInfo.ProductUpdateLevel)`n\"\n            $serverCsv += \"Update Status,$($serverInfo.UpdateStatus)`n\"\n            $cuLink = $serverInfo.LatestCU -replace '\\[|\\]', ''\n            $serverCsv += \"Latest CU Download,$cuLink`n\"\n            $serverCsv += \"Is Clustered,$($serverInfo.IsClustered)`n\"\n            $serverCsv += \"HADR Enabled,$($serverInfo.IsHadrEnabled)\"\n            \n            # Availability Groups CSV\n            $agCsv = \"\"\n            if ($allData.availabilityGroups.Count -gt 0) {\n                $agCsv = \"AG Name,Primary Replica,Role,Listener DNS,Listener Port,Listener IP,Replicas`n\"\n                foreach ($ag in $allData.availabilityGroups) {\n                    $agCsv += \"$($ag.Name),$($ag.PrimaryReplica),$($ag.LocalReplicaRole),$($ag.ListenerDNS),$($ag.ListenerPort),$($ag.ListenerIP),`\"$($ag.Replicas)`\"`n\"\n                }\n                $agCsv = $agCsv.TrimEnd(\"`n\")\n            }\n            \n            # Databases CSV\n            $dbCsv = \"\"\n            if ($allData.databases.Count -gt 0) {\n                $dbCsv = \"Database,Data (GB),Log (GB),Total (GB),Status,Recovery Model,Owner,Connections,Last Backup,In AG`n\"\n                foreach ($db in $allData.databases) {\n                    $dbCsv += \"$($db.DatabaseName),$($db.DataSizeGB),$($db.LogSizeGB),$($db.TotalSizeGB),$($db.Status),$($db.RecoveryModel),$($db.Owner),$($db.ActiveConnections),$($db.LastFullBackup),$($db.InAvailabilityGroup)`n\"\n                }\n                $dbCsv = $dbCsv.TrimEnd(\"`n\")\n            }\n            \n            # Database Users CSV\n            $usersCsv = \"\"\n            if ($allData.databaseUsers.Count -gt 0) {\n                $usersCsv = \"Database,User Name,Login Type,Roles,Has DB Access,Created`n\"\n                foreach ($user in $allData.databaseUsers) {\n                    $usersCsv += \"$($user.DatabaseName),$($user.UserName),$($user.LoginType),`\"$($user.Roles)`\",$($user.HasDBAccess),$($user.CreateDate)`n\"\n                }\n                $usersCsv = $usersCsv.TrimEnd(\"`n\")\n            }\n            \n            if ($exportToFile) {\n                # Write separate CSV files for each section\n                $serverFile = \"server_info_$($serverInfo.ServerName)_$timestamp.csv\"\n                $serverCsv | Out-File -FilePath $serverFile -Encoding UTF8 -NoNewline\n                Write-Host \"Server CSV file created: $serverFile\"\n                $csvFiles += @{ path = $serverFile; name = $serverFile }\n                \n                if ($agCsv) {\n                    $agFile = \"availability_groups_$($serverInfo.ServerName)_$timestamp.csv\"\n                    $agCsv | Out-File -FilePath $agFile -Encoding UTF8 -NoNewline\n                    Write-Host \"AG CSV file created: $agFile\"\n                    $csvFiles += @{ path = $agFile; name = $agFile }\n                }\n                \n                if ($dbCsv) {\n                    $dbFile = \"databases_$($serverInfo.ServerName)_$timestamp.csv\"\n                    $dbCsv | Out-File -FilePath $dbFile -Encoding UTF8 -NoNewline\n                    Write-Host \"Databases CSV file created: $dbFile\"\n                    $csvFiles += @{ path = $dbFile; name = $dbFile }\n                }\n                \n                if ($usersCsv) {\n                    $usersFile = \"database_users_$($serverInfo.ServerName)_$timestamp.csv\"\n                    $usersCsv | Out-File -FilePath $usersFile -Encoding UTF8 -NoNewline\n                    Write-Host \"Users CSV file created: $usersFile\"\n                    $csvFiles += @{ path = $usersFile; name = $usersFile }\n                }\n                \n                # Build combined CSV content for data field\n                $combinedCsv = \"# Server Information`n\" + $serverCsv\n                if ($agCsv) { $combinedCsv += \"`n`n# Availability Groups`n\" + $agCsv }\n                if ($dbCsv) { $combinedCsv += \"`n`n# Databases`n\" + $dbCsv }\n                if ($usersCsv) { $combinedCsv += \"`n`n# Database Users`n\" + $usersCsv }\n                \n                # Output with file references\n                Write-Output-JSON @{\n                    xy = 1\n                    data = $combinedCsv\n                    files = $csvFiles\n                }\n            } else {\n                # Build combined CSV for data output only\n                $combinedCsv = \"# Server Information`n\" + $serverCsv\n                if ($agCsv) { $combinedCsv += \"`n`n# Availability Groups`n\" + $agCsv }\n                if ($dbCsv) { $combinedCsv += \"`n`n# Databases`n\" + $dbCsv }\n                if ($usersCsv) { $combinedCsv += \"`n`n# Database Users`n\" + $usersCsv }\n                \n                Write-Output-JSON @{\n                    xy = 1\n                    data = $combinedCsv\n                }\n            }\n        }\n        \"MD\" {\n            if ($exportToFile) {\n                # Generate filename with timestamp\n                $timestamp = Get-Date -Format \"yyyyMMdd_HHmmss\"\n                $filename = \"sqlserver_info_$($serverInfo.ServerName)_$timestamp.md\"\n                \n                # Write Markdown to file\n                $markdownContent | Out-File -FilePath $filename -Encoding UTF8 -NoNewline\n                Write-Host \"Markdown file created: $filename\"\n                \n                # Output markdown content directly as data AND file reference\n                $mdData = @{\n                    xy = 1\n                    data = $markdownContent\n                    files = @(\n                        @{\n                            path = $filename\n                            name = $filename\n                        }\n                    )\n                }\n                Write-Output-JSON $mdData\n            } else {\n                # Output markdown directly (no file)\n                $mdData = @{\n                    xy = 1\n                    data = $markdownContent\n                }\n                Write-Output-JSON $mdData\n            }\n        }\n        default {\n            Write-Host \"Unknown export format: $exportFormat, defaulting to JSON\"\n            $jsonData = @{\n                xy = 1\n                data = $allData\n            }\n            Write-Output-JSON $jsonData\n        }\n    }\n    \n    # Success message\n    $totalDatabases = $allData.databases.Count\n    $totalAGs = $allData.availabilityGroups.Count\n    $totalUsers = $allData.databaseUsers.Count\n    \n    $summary = \"Information collected successfully: $totalDatabases database(s), $totalUsers user(s)\"\n    if ($totalAGs -gt 0) {\n        $summary += \", $totalAGs Availability Group(s)\"\n    }\n    \n    Send-Success -Description $summary\n}\ncatch {\n    Send-Error -Code 5 -Description \"Error: $($_.Exception.Message)\"\n    exit 1\n}",
				"groups": [],
				"format": "",
				"params": [
					{
						"id": "server",
						"title": "MSSQL server",
						"type": "text",
						"caption": "Hostname or IP address to the MSSQL server",
						"locked": false,
						"value": "",
						"variant": "text",
						"required": true
					},
					{
						"id": "useencryption",
						"title": "Use encryption",
						"type": "checkbox",
						"caption": "Use encrypted connection.",
						"locked": false,
						"value": false
					},
					{
						"id": "trustcert",
						"title": "Trust certificate",
						"type": "checkbox",
						"caption": "Trust the certificate.",
						"locked": false,
						"value": false
					},
					{
						"id": "debug",
						"title": "Enable debug mode",
						"type": "checkbox",
						"caption": "Write the JSON parameters to the job output.",
						"locked": false,
						"value": false
					}
				],
				"kill": "parent",
				"runner": false,
				"notes": "",
				"icon": "database",
				"uid": "",
				"gid": "",
				"id": "pml29q39uxnfq41a"
			}
		}
	]
}
